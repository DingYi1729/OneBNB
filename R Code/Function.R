# This function is to load all the packages needed.
library(statnet)
library(irlba)
library(foreach)
library(plyr)
library(igraph)
library(reshape2)
library(actuar)
library(poweRlaw)
library(R.matlab)
library(MASS)
library(sets)
library(snowboot)
library(CVXR)
library(expm)
library(doParallel)
library(ggplot2)
library(ggpubr)
library(ggThemeAssist)

# This function is to obtain the degree distribution of an undirected graph.
Count_Degree = function(W){
  gg = graph_from_adjacency_matrix(W,mode = "undirected")
  degree_freq = mutate(data.frame(table(list(igraph::degree(gg)))),
                       proportion = Freq/length(V(gg)),
                       logodds = log(proportion/(1-proportion)))
  return(degree_freq)
}

# This function is to obtain the confidence intervals estimated via the 1-BNB method.
OneBNB_Degree_CI = 
  function(Degree_Sequence, Bootstrap_Samples, Sample_Number, Alpha){
    ## Degree_Sequence  : a subset of the original degree sequence chosen for better display.
    ## Bootstrap_Samples: network bootstrap samples obtained via 1-BNB method.
    ## Sample_Number    : the number of bootstrap samples.
    ## Alpha            : 1 - confidence level. 
    
    # Read the boostrap samples generated by the 1-BNB method and the number of samples.
    Yhat = Bootstrap_Samples
    B = Sample_Number
    Y_comp = list()
    for (i in 1:B) {
      Y_comp[[i]] = as.matrix(Yhat[which(Yhat[,ncol(Yhat)] == i), -ncol(Yhat)])
    }
    
    # Obtain the degree distribution of each bootstrap sample.
    ## 'degree_result1' stores the estimated probability of each degree (row) for all B samples (column).
    degree_B = lapply(Y_comp, Count_Degree)
    max_degree = 0 
    for (i in 1:B){
      max0 = max(as.numeric(as.character(degree_B[[i]]$Var1)))
      if (max_degree < max0){
        max_degree = max0
      }
    }
    degree_result1 = data.frame(Var1 = 0:max_degree)
    for (i in 1:B){
      degree_result1 = merge(degree_result1,degree_B[[i]][c('Var1','proportion')],by='Var1', all.x = TRUE)
    }
    degree_result1[is.na(degree_result1)] = 0
    columnnames = list()
    columnnames[1] = 'degree'
    for (i in 2:B+1){
      columnnames[i] = paste0("proportion_",i)
    }
    
    ## Choose degree from the pre-given 'Degree-Sequence' for better display.
    degree_result1_subset = degree_result1[Degree_Sequence+1,]
    max_degree_subset = max(degree_result1_subset$Var1)
    
    ## Rearrange degree_result1 for further coding.
    colnames(degree_result1_subset) = unlist(columnnames)
    degree_result11 = melt(degree_result1_subset, id.vars = c("degree"))
    
    ## Obtain confidence intervals (CI) of degree distribution for degree in 'Degree_Sequence'.
    degree_CI = NULL
    for (j in Degree_Sequence) { 
      # Obtain all B estimated probability of degree j, and store the result in f.
      f = degree_result11[which(degree_result11$degree == j),3] 
      
      # From f obtain the quantile confidence limits for degree j
      ## with upper limits stored in up and lower limits stored in low.
      f_sort = sort(f)
      alpha = Alpha
      low = f_sort[round(B*alpha/2)]
      up = f_sort[round(B*(1-alpha/2))]
      
      ## Store CI results in 'degree_CI' for all degree in 'Degree_Sequence'.
      temp = c(j, low, up)
      degree_CI = rbind(degree_CI, temp)
    }
    colnames(degree_CI) = c("degree", "low", "up")
    rownames(degree_CI) = Degree_Sequence
    degree_CI = as.data.frame(degree_CI)
    return(degree_CI)
  }

# This function is to plot the estimated confidence intervals along with the baseline degree distribution.
Degree_CI_Plot = function(Degree_CI, Degree_Distribution, Degree_Sequence){
  ## Degree_CI: 
  ## the estimated boostrap confidence intervals for degree distribution
  ## Degree_Distribution:
  ## the degree distribution one want to set as a baseline, whether it is theoretical or observed.
  ## Degree_Sequence:
  ## a subset of the original degree sequence chosen for better display.
  Start = Degree_Sequence[1]
  End   = Degree_Sequence[length(Degree_Sequence)]
  Degree_CI_Plot = 
    ggplot() +
    geom_errorbar(aes(x = degree, ymin = low, ymax = up), data = Degree_CI) +
    geom_line(aes(x = Degree_Distribution$degree,
                  y = Degree_Distribution$proportion, group = 1),color = "red") +
    geom_point(aes(x = Degree_Distribution$degree,
                   y = Degree_Distribution$proportion, group = 1),color = "red") +
    coord_cartesian(xlim = c(Start,End)) +
    scale_x_continuous(breaks = Degree_Sequence) +
    xlab('degree') + ylab('proportion of nodes') + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 0, hjust = 0.4),
          text = element_text(family="Times New Roman"),
          panel.grid.major=element_blank(),
          plot.title = element_text(hjust = 0.5))
  Degree_CI_Plot
}

# This function is to create a dataframe for the theoretical degree distribution for further analysis.
Theoretical_Degree_Distribution = function(Degree_Sequence, type, palpha = 2, gprob = 0.2){
  ## Degree_Sequence: a subset of the original degree sequence chosen for better display.
  ## type:            the type of degree distribution. It could be power-law with parameter 2 or 3, or geometric with parameter 0.2 or 0.4.
  if (type == 'powerlaw'){ ## Power-law with parameter 2.
    Degree_Distribution = NULL
    Degree_Distribution = cbind(Degree_Distribution, Degree_Sequence)
    Degree_Distribution = cbind(Degree_Distribution, dpldis(Degree_Sequence + 1, 1, palpha))
    colnames(Degree_Distribution) = c("degree","proportion")
    Degree_Distribution = as.data.frame(Degree_Distribution)
  }else if (type == 'geom'){ ## Geometric with parameter 0.2.
    Degree_Distribution = NULL
    Degree_Distribution = cbind(Degree_Distribution, Degree_Sequence)
    Degree_Distribution = cbind(Degree_Distribution, dgeom(Degree_Sequence, gprob))
    colnames(Degree_Distribution) = c("degree","proportion")
    Degree_Distribution = as.data.frame(Degree_Distribution)
  }else{
    print('Pleas enter powerlaw or geom as type.')
    Degree_Distribution = NULL
  }
  return(Degree_Distribution)
}

# This function is to extract a part of a degree distribution for better display.
Degree_Distribution_Extract = function(AdjacencyMatrix, Degree_Sequence){
  ## AdjacencyMatrix : the adjacency matrix.
  ## Degree_Sequence : a subset of the original degree sequence chosen for better display.
  G = graph_from_adjacency_matrix(AdjacencyMatrix, mode = "undirected")
  Degree_Distribution = 
    mutate(data.frame(table(list(igraph::degree(G)))),
           proportion = Freq/length(V(G)),
           logodds = log(proportion/(1-proportion)))
  Degree_Distribution$Var1 = as.numeric(as.character(Degree_Distribution$Var1))
  Degree_Distribution = Degree_Distribution[Degree_Distribution$Var1 >=
                                              Degree_Sequence[1],]
  Degree_Distribution = Degree_Distribution[Degree_Distribution$Var1 <=
                                              Degree_Sequence[length(Degree_Sequence)],]
  return(Degree_Distribution)
}

# This function is to obtain Coverage Probability(CR) and Average Width(AW) 
# to evaluate the performance of the 1-BNB method.
OneBNB_Evaluation = function(OneBitPowBoots, LoopNum, Sample_Number, Alpha, 
                             Degree_Sequence, type, palpha = 2, gprob = 0.2){
  ## OneBitPowBoots   : The batch of bootstrap samples for the generated networks.
  ## LoopNum          : The number of the generated networks.
  ## Sample_Number    : the number of bootstrap samples.
  ## Alpha            : 1 - confidence level.
  ## Degree_Sequence  : a subset of the original degree sequence chosen for better display.
  ## type             : the type of degree distribution. It could be power-law with parameter 2 or 3, or geometric with parameter 0.2 or 0.4.
  Prop  = NULL ## Used to store for all networks, whether or not each estimated CI can cover f(k).
  Width = NULL ## Used to store for all networks, the width of each estimated CI.
  if (type == 'powerlaw'){ ## Power-law with parameter 2.
    for (n in 1:LoopNum) {
      k = NULL ## Used to store for a single network, whether or not the estimated CI can cover f(k).
      w = NULL ## Used to store for a single network, the width of the estimated CI.
      # Read the bootstrap samples for a single network indexed by 'n'.
      Yhat = OneBitPowBoots[which(OneBitPowBoots[,ncol(OneBitPowBoots)] == n), ]
      Yhat = Yhat[, -ncol(Yhat)]
      Degree_CI = ## Store confidence intervals in Degree_CI.
        OneBNB_Degree_CI(Degree_Sequence = Degree_Sequence,
                         Bootstrap_Samples = Yhat,
                         Sample_Number = Sample_Number,
                         Alpha = Alpha)
      for (j in Degree_Sequence) {
        low = Degree_CI[j+1,2] ## The lower confidence limit.
        up  = Degree_CI[j+1,3] ## The upper confidence limit.
        k = append(k, (dpldis(j+1,1,palpha) <= up) * (dpldis(j+1,1,palpha) >= low))
        w = append(w, up - low)
      }
      Prop  = rbind(Prop,  k)
      Width = rbind(Width, w)
      print(n)
    }
  }else if (type == 'geom'){ ## Geometric with parameter 0.2.
    for (n in 1:LoopNum) {
      k = NULL ## Used to store for a single network, whether or not the estimated CI can cover f(k).
      w = NULL ## Used to store for a single network, the width of the estimated CI.
      # Read the bootstrap samples for a single network indexed by 'n'.
      Yhat = OneBitPowBoots[which(OneBitPowBoots[,ncol(OneBitPowBoots)] == n), ]
      Yhat = Yhat[, -ncol(Yhat)]
      Degree_CI = ## Store confidence intervals in Degree_CI.
        OneBNB_Degree_CI(Degree_Sequence = Degree_Sequence,
                         Bootstrap_Samples = Yhat,
                         Sample_Number = Sample_Number,
                         Alpha = Alpha)
      for (j in Degree_Sequence) { ## Geometric with parameter 0.4.
        low = Degree_CI[j+1,2] ## The lower confidence limit.
        up  = Degree_CI[j+1,3] ## The upper confidence limit.
        k = append(k, (dgeom(j,gprob) <= up) * (dgeom(j,gprob) >= low))
        w = append(w, up - low)
      }
      Prop  = rbind(Prop,  k)
      Width = rbind(Width, w)
      print(n)
    }
  } else{
    print('Pleas enter powerlaw2, powerlaw3, geom02 or geom04.')
  }
  CP = apply(Prop,  2, mean) ## CP: Coverage Probability.
  AW = apply(Width ,2, mean) ## AW: Average Width.
  Eval = cbind(Degree_Sequence, CP,AW)
  colnames(Eval) = c('Degree','CP','AW')
  return(Eval)
}

# This function is to obtain Coverage Probability(CR) and Average Width(AW) 
# to evaluate the performance of the 1-BNB method.
SnowBoot_Evaluation = function(Simulation_Data, Degree_Sequence, 
                               LoopNum, Sample_Number, Alpha,
                               type, palpha = 2, gprob =0.2){
  ## Simulation Data  : The generated networks data for simulation.
  ## Degree_Sequence  : a subset of the original degree sequence chosen for better display.
  ## LoopNum          : The number of the generated networks.
  ## Sample_Number    : the number of bootstrap samples.
  ## Alpha            : 1 - confidence level.
  ## type             : the type of degree distribution. It could be power-law with parameter 2 or 3, or geometric with parameter 0.2 or 0.4.
  B = Sample_Number ## Number of bootstrap samples.
  SnowDegreeProp = NULL ## Used to store for all networks, whether or not each estimated CI can cover f(k).
  SnowWidth = NULL      ## Used to store for all networks, the width of each estimated CI.
  for (n in 1:LoopNum) {
    ## Read a single network which is stored in the form of adjacency matrix.
    A = Simulation_Data[which(Simulation_Data[,ncol(Simulation_Data)] == n),
                        -ncol(Simulation_Data)]
    A = as.matrix(A)
    ## Use the adjacency matrix to generate the corresponding network.
    g = graph.adjacency(A, mode = 'undirected')
    net = igraph_to_network(g)
    ## Begin the SnowBoot method.
    ## Obtain bootstrap samples, i.e., 'patches'.
    set.seed(1)
    patches = lsmi_union(net, n.seeds = 60, n.wave = 5)  
    ## Obtain degree distribution estimated from the patches.
    empdd = lsmi_dd(patches$lsmi_big, net)
    bootdd = boot_dd(empdd, B)
    bootdd$fkb = rbind(bootdd$fkb, rep(0,LoopNum))
    bootdd$fkb[1,] = 1 - colSums(bootdd$fkb[-1,])
    dim = dim(bootdd$fkb)
    rowend = dim[1]
    ## The estimated degree distribution is stored in 'bootdd$fkb'.
    bootdd$fkb = bootdd$fkb[-rowend,]
    ## Rearrange 'bootdd$fkb' for further coding.
    Snow_MaxDegree = max(as.numeric(rownames(bootdd$fkb)))
    SnowDegreeResult = seq(0,Snow_MaxDegree,1)
    SnowDegreeResult = cbind(SnowDegreeResult, bootdd$fkb)
    SnowDegreeResult = as.data.frame(SnowDegreeResult)
    columnnames = list()
    columnnames[1] = 'degree'
    for (i in 2:B+1){
      columnnames[i] = paste0("proportion_",i)
    }
    colnames(SnowDegreeResult) = unlist(columnnames)
    SnowDegreeResult11 = melt(SnowDegreeResult, id.vars = c("degree"))
    
    k = NULL ## Used to store for a single network, whether or not the estimated CI can cover f(k).
    w = NULL ## Used to store for a single network, the width of the estimated CI.
    for (j in Degree_Sequence) {
      f = SnowDegreeResult11[which(SnowDegreeResult11$degree == j),3]
      f_sort = sort(f)
      alpha = Alpha
      low = f_sort[round(B*alpha/2)]    ## The lower confidence interval.
      up = f_sort[round(B*(1-alpha/2))] ## The upper confidence interval.
      if (type == 'powerlaw'){
        k = append(k, (dpldis(j+1,1,palpha) <= up)*(dpldis(j+1,1,palpha) >= low))
      }else if (type == 'geom'){
        k = append(k, (dgeom(j,gprob) <= up) * (dgeom(j,gprob) >= low))
      }
      else{
        print('Pleas enter powerlaw or geom.')
      }
      w = append(w, up - low)
    }
    SnowDegreeProp = rbind(SnowDegreeProp,k)
    SnowWidth = rbind(SnowWidth, w)
  }
  ave = function(x){
    mean(x, na.rm = TRUE)
  }
  CP = apply(SnowDegreeProp, 2, ave) ## CP: Coverage Probability.
  AW = apply(SnowWidth ,2, ave)      ## AW: Average Width.
  Eval = cbind(Degree_Sequence, CP,AW)
  colnames(Eval) = c('Degree','CP','AW')
  return(Eval)
}

# This function is to obtain the SnowBoot-estimated confidence intervals for degree distribution. 
SnowBoot_Degree_CI = 
  function(Degree_Sequence, Adjacency_Matrix, Sample_Number, Alpha, n.wave = 5){
    ## Degree_Sequence  : a subset of the original degree sequence chosen for better display.
    ## Adjacency_Matrix : the corresponding adjacency matrix of the network that needs analyzing.
    ## Sample_Number    : the number of bootstrap samples.
    ## Alpha            : 1 - confidence level. 
    ## Read a single network which is stored in the form of adjacency matrix.
    G = graph.adjacency(Adjacency_Matrix, mode = 'undirected')
    Network = igraph_to_network(G)
    ## Obtain bootstrap samples, i.e., 'patches'.
    set.seed(1)
    cv = lsmi_cv(Network, n.seeds = seq(30,60), n.wave, B = Sample_Number)
    nseed = cv$best_combination[1]
    nwave = cv$best_combination[2]
    set.seed(1)
    patches = lsmi_union(Network, n.seeds = nseed, n.wave = nwave)
    ## Obtain degree distribution estimated from the patches.
    empdd = lsmi_dd(patches$lsmi_big, Network)
    B = Sample_Number
    bootdd = boot_dd(empdd, B)
    bootdd$fkb[1,] = 1 - colSums(bootdd$fkb[-1,])
    ## Obtain CI estimated via the SnowBoot method.
    CIpercentile = boot_ci(bootdd, prob = 1-Alpha)
    CI = CIpercentile$fk_ci
    CI_subset = CI[,Degree_Sequence + 1]
    Degree_CI_snow = cbind(Degree_Sequence, CI_subset[1,], CI_subset[2,])
    colnames(Degree_CI_snow) = c("degree", "low", "up")
    rownames(Degree_CI_snow) = Degree_Sequence
    Degree_CI_snow = as.data.frame(Degree_CI_snow)
    return(Degree_CI_snow)
  }

# This function is to obtain the SnowBoot-estimated confidence intervals for degree distribution. 
SnowBoot_Degree_CI2 = 
  function(Degree_Sequence, Adjacency_Matrix, Sample_Number, Alpha, n.wave = 5){
    ## Degree_Sequence  : a subset of the original degree sequence chosen for better display.
    ## Adjacency_Matrix : the corresponding adjacency matrix of the network that needs analyzing.
    ## Sample_Number    : the number of bootstrap samples.
    ## Alpha            : 1 - confidence level. 
    ## Read a single network which is stored in the form of adjacency matrix.
    G = graph.adjacency(Adjacency_Matrix, mode = 'undirected')
    Network = igraph_to_network(G)
    ## Obtain bootstrap samples, i.e., 'patches'.
    set.seed(1)
    cv = lsmi_cv(Network, n.seeds = seq(30,60), n.wave, B = Sample_Number)
    nseed = cv$best_combination[1]
    nwave = cv$best_combination[2]
    set.seed(1)
    patches = lsmi_union(Network, n.seeds = nseed, n.wave = nwave)
    ## Obtain degree distribution estimated from the patches.
    empdd = lsmi_dd(patches$lsmi_big, Network)
    B = Sample_Number
    bootdd = boot_dd(empdd, B)
    bootdd$fkb[1,] = 1 - colSums(bootdd$fkb[-1,])
    ## Obtain CI estimated via the SnowBoot method.
    CIpercentile = boot_ci(bootdd, prob = 1-Alpha)
    CI = CIpercentile$fk_ci
    fill_fun = function(x,maxlen){
      length = maxlen - length(x)
      if (length > 0){
        y = c(x, rep(0,length))
      }
      else{
        y = x[1:maxlen]
      }
    }
    CI_subset = matrix(0,2,max(Degree_Sequence) + 1)
    CI_subset[1,] = fill_fun(CI[1,],maxlen = max(Degree_Sequence) + 1)
    CI_subset[2,] = fill_fun(CI[2,],maxlen = max(Degree_Sequence) + 1)
    Degree_CI_snow = cbind(Degree_Sequence, CI_subset[1,], CI_subset[2,])
    colnames(Degree_CI_snow) = c("degree", "low", "up")
    rownames(Degree_CI_snow) = Degree_Sequence
    Degree_CI_snow = as.data.frame(Degree_CI_snow)
    return(Degree_CI_snow)
  }

# This function is to perform random node selection.
Node_Sample = function(g,prob,seed){
  p = prob
  b = seed
  vid = V(g)
  m = length(vid)
  set.seed(b)
  vid_bern = rbinom(m,1,p)
  vid_sample = vid * vid_bern
  vid_sample = vid_sample[which(vid_sample>0)]
  return(vid_sample)
}

# This function is to perform random node pair selection.
Pair_Sample = function(graph,prob,seed){
  A = as_adjacency_matrix(graph)
  A = as.matrix(A)
  A_vec = as.vector(A)
  pair_id = 1:nrow(A)^2
  set.seed(seed)
  pair_id_sample = rbinom(m^2,1,prob)
  pair_sample = pair_id * pair_id_sample
  pair_sample = pair_sample[which(pair_sample>0)]
  size = floor(sqrt(length(pair_sample)))
  pair_sample = pair_sample[1:size^2]
  A_vec_sample = A_vec[pair_sample]
  A_sample = matrix(A_vec_sample,size,size)
  A_sample[lower.tri(A_sample)] = t(A_sample)[lower.tri(A_sample)]
  return(A_sample)
}
Get_Neighbors = function(graph,id){
  id_neighbors = neighbors(g,id[1])
  for (i in 2:length(id)) {
    id_neighbors = c(id_neighbors,neighbors(g,id[i]))
  }
  return(id_neighbors)
}

# This function is to perform snowball sampling.
Snow_Sample = function(g,id,nwave){
  id_snow = id
  for (w in 1:(nwave+1)) {
    id_snow = union(id_snow,Get_Neighbors(g,id_snow))
  }
  return(id_snow)
}

# This function is to perform CVE estimation of degree distribution.
CVX_Estimate = function(m,Nstar,P,C,D,lambda){
  N = Variable(length(Nstar))
  Cinv = solve(C)
  sqrtCinv = sqrtm(Cinv)
  objective = Minimize(sum_squares(t(P%*%N - Nstar)%*%sqrtCinv) + 
                         lambda * sum_squares(D %*% N))
  constraints = list(N >= 0, sum(N) == m)
  prob = Problem(objective, constraints)
  solution = solve(prob)
  Deg =solution$getValue(N)/m
  obj = solution$value
  return(list(Deg = Deg,obj = obj))
}
fill_fun = function(x,maxlen){
  length = maxlen - length(x)
  if (length > 0){
    y = c(x, rep(0,length))
  }
  else{
    y = x[1:maxlen]
  }
  return(y)
}
DegreeCI_Evaluation = function(degree_CI,Degree_Sequence,type,
                               palpha = 2, gprob = 0.2){
  k = NULL ## Used to store for a single network, whether or not the estimated CI can cover f(k).
  w = NULL ## Used to store for a single network, the width of the estimated CI.
  for (j in Degree_Sequence) {
    if (type == 'powerlaw'){
      k = append(k, (dpldis(j+1,1,palpha) <= degree_CI$up[j+1])*(dpldis(j+1,1,palpha) >= degree_CI$low[j+1]))
    }else if (type == 'geom'){
      k = append(k, (dgeom(j,gprob) <= degree_CI$up[j+1]) * (dgeom(j,gprob) >= degree_CI$low[j+1]))
    }else{
      print('Pleas enter powerlaw or geom.')
    }
    w = append(w, degree_CI$up[j+1]-degree_CI$low[j+1])
  }
  return(list(k = k, w = w))
}
